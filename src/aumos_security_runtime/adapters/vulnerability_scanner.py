"""Vulnerability Scanner adapter — CVE and dependency vulnerability detection.

Scans Python package dependencies and container images for known vulnerabilities
using pip-audit and Trivy integrations. Classifies findings by CVSS score, generates
remediation suggestions, and produces scan reports suitable for security compliance
dashboards and CI/CD gating.

Methods:
- pip-audit: Python package vulnerability scanning against OSV/PyPA advisories
- Trivy: Container image scanning for OS packages, libraries, and secrets
- CVE classification: CVSS v3 severity mapping (critical/high/medium/low/informational)
- Remediation suggestions: per-vulnerability fix version recommendations
- Scan scheduling: on-demand and scheduled scan support
- Report generation: SBOM-enriched vulnerability report in JSON format

Note: Trivy is called as a subprocess (external binary). pip-audit is called
via Python API if installed, or subprocess fallback.

IMPORTANT: This adapter makes subprocess calls. Do NOT use it in the <50ms
hot-path scan. It is intended for background security jobs, not per-request scanning.
"""

import importlib.util
import json
import subprocess
from dataclasses import dataclass, field
from typing import Any

from aumos_common.observability import get_logger

logger = get_logger(__name__)


def _is_trivy_available() -> bool:
    """Check whether Trivy binary is on PATH.

    Returns:
        True if 'trivy' is executable, False otherwise.
    """
    try:
        result = subprocess.run(
            ["trivy", "--version"],
            capture_output=True,
            timeout=10,
        )
        return result.returncode == 0
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError):
        return False


def _is_pip_audit_available() -> bool:
    """Check whether pip-audit is installed.

    Returns:
        True if pip_audit Python module is importable, False otherwise.
    """
    return importlib.util.find_spec("pip_audit") is not None


# CVSS v3 severity thresholds
CVSS_SEVERITY_MAP: dict[str, tuple[float, float]] = {
    "critical": (9.0, 10.0),
    "high": (7.0, 8.9),
    "medium": (4.0, 6.9),
    "low": (0.1, 3.9),
    "informational": (0.0, 0.0),
}


@dataclass
class Vulnerability:
    """A single detected software vulnerability.

    Attributes:
        cve_id: CVE identifier (e.g., 'CVE-2024-12345').
        package_name: Affected package or component name.
        installed_version: Currently installed version.
        fixed_version: Earliest version that resolves the vulnerability.
        severity: CVSS severity tier ('critical', 'high', 'medium', 'low').
        cvss_score: CVSS v3 base score (0.0–10.0).
        description: Brief description of the vulnerability.
        references: List of advisory URLs.
        remediation: Recommended fix action.
        scan_target: What was scanned ('python_deps', 'container', 'os_packages').
    """

    cve_id: str
    package_name: str
    installed_version: str
    fixed_version: str
    severity: str
    cvss_score: float
    description: str
    references: list[str]
    remediation: str
    scan_target: str
    exploitability_score: float = 0.0
    has_exploit: bool = False
    tags: list[str] = field(default_factory=list)


@dataclass
class VulnerabilityScanResult:
    """Result of a vulnerability scan operation.

    Attributes:
        is_threat: Whether any critical or high vulnerabilities were found.
        threat_type: 'vulnerability_detected' when is_threat is True.
        severity: Highest severity found ('critical', 'high', 'medium', 'low', 'none').
        confidence: Detection confidence (always 1.0 for CVE database matches).
        details: Scan metadata.
        vulnerabilities: All detected vulnerabilities.
        n_critical: Count of critical severity findings.
        n_high: Count of high severity findings.
        n_medium: Count of medium severity findings.
        n_low: Count of low severity findings.
        scan_target: What was scanned.
        scanner_used: Which scanner tool produced these results.
    """

    is_threat: bool
    threat_type: str
    severity: str
    confidence: float
    details: dict[str, Any]
    vulnerabilities: list[dict[str, Any]]
    n_critical: int
    n_high: int
    n_medium: int
    n_low: int
    scan_target: str
    scanner_used: str


class VulnerabilityScanner:
    """CVE and dependency vulnerability scanner for the AumOS security pipeline.

    Integrates pip-audit (Python package scanning) and Trivy (container image
    scanning) to detect known vulnerabilities in the software supply chain.
    Produces structured scan results with remediation guidance for CI/CD gating
    and security compliance reporting.

    Not suitable for the <50ms request hot path — intended for background security
    scans triggered by deployment events or scheduled jobs.

    Args:
        fail_on_severity: Minimum severity to classify as a threat ('critical', 'high', etc.).
        trivy_timeout_seconds: Timeout for Trivy subprocess calls.
        include_unfixed: Whether to include vulnerabilities with no known fix.
        max_vulnerabilities_per_scan: Cap on returned vulnerabilities per scan.
    """

    def __init__(
        self,
        fail_on_severity: str = "high",
        trivy_timeout_seconds: float = 120.0,
        include_unfixed: bool = True,
        max_vulnerabilities_per_scan: int = 200,
    ) -> None:
        """Initialize the VulnerabilityScanner.

        Args:
            fail_on_severity: Threshold severity to flag as is_threat.
            trivy_timeout_seconds: Max wait time for Trivy subprocess.
            include_unfixed: Include CVEs with no available fix.
            max_vulnerabilities_per_scan: Maximum findings per scan.
        """
        self._fail_on_severity = fail_on_severity
        self._trivy_timeout = trivy_timeout_seconds
        self._include_unfixed = include_unfixed
        self._max_vulns = max_vulnerabilities_per_scan

    def is_available(self) -> bool:
        """Return True if at least one scanning backend is available.

        Returns:
            True if pip-audit or Trivy is installed.
        """
        return _is_pip_audit_available() or _is_trivy_available()

    async def scan(self, content: str) -> list[dict[str, Any]]:
        """Scan content for vulnerability indicators (IScannerResult interface).

        Content is expected to be a JSON requirements.txt payload or image reference.
        Parses the content type and delegates to the appropriate scanner.

        Args:
            content: Either an image reference ('python_deps' or 'image:tag') or
                     JSON-encoded package list.

        Returns:
            List of IScannerResult-compatible dicts.
        """
        scan_result = await self.scan_python_dependencies()

        if not scan_result.is_threat:
            return []

        return [
            {
                "threat_type": "vulnerability_detected",
                "severity": scan_result.severity,
                "confidence": scan_result.confidence,
                "is_threat": scan_result.is_threat,
                "details": {
                    "n_critical": scan_result.n_critical,
                    "n_high": scan_result.n_high,
                    "n_medium": scan_result.n_medium,
                    "n_low": scan_result.n_low,
                    "scanner": scan_result.scanner_used,
                },
            }
        ]

    async def initialize(self) -> None:
        """No-op — no pre-loading required for subprocess-based scanners."""
        logger.info(
            "VulnerabilityScanner initialized",
            pip_audit_available=_is_pip_audit_available(),
            trivy_available=_is_trivy_available(),
            fail_on_severity=self._fail_on_severity,
        )

    async def scan_python_dependencies(
        self,
        requirements_file: str | None = None,
    ) -> VulnerabilityScanResult:
        """Scan Python package dependencies for known CVEs using pip-audit.

        Runs pip-audit against the current environment or a specified
        requirements.txt file. Parses JSON output and maps results to
        Vulnerability dataclasses with CVSS severity classification.

        Args:
            requirements_file: Path to requirements.txt. If None, scans current env.

        Returns:
            VulnerabilityScanResult with all detected dependency vulnerabilities.
        """
        logger.info(
            "Starting Python dependency vulnerability scan",
            scanner="pip_audit",
            requirements_file=requirements_file,
        )

        if _is_pip_audit_available():
            return await self._scan_with_pip_audit_api(requirements_file)
        else:
            return await self._scan_with_pip_audit_subprocess(requirements_file)

    async def scan_container_image(
        self,
        image_reference: str,
        include_os_packages: bool = True,
        include_language_packages: bool = True,
    ) -> VulnerabilityScanResult:
        """Scan a container image for vulnerabilities using Trivy.

        Pulls and scans the specified container image using the Trivy binary.
        Reports OS package, library, and language package vulnerabilities.

        Args:
            image_reference: Docker image reference (e.g., 'myapp:latest').
            include_os_packages: Scan OS-level packages.
            include_language_packages: Scan language runtime packages.

        Returns:
            VulnerabilityScanResult with container vulnerability findings.

        Raises:
            RuntimeError: If Trivy is not installed.
        """
        if not _is_trivy_available():
            raise RuntimeError(
                "Trivy is required for container scanning. "
                "Install from: https://github.com/aquasecurity/trivy/releases"
            )

        logger.info(
            "Starting container image vulnerability scan",
            scanner="trivy",
            image=image_reference,
        )

        return await self._scan_with_trivy(
            image_reference=image_reference,
            include_os=include_os_packages,
            include_lang=include_language_packages,
        )

    async def scan_all(
        self,
        image_reference: str | None = None,
        requirements_file: str | None = None,
    ) -> dict[str, VulnerabilityScanResult]:
        """Run all available vulnerability scans.

        Args:
            image_reference: Optional container image to scan with Trivy.
            requirements_file: Optional requirements.txt path for pip-audit.

        Returns:
            Dict mapping scan_type to VulnerabilityScanResult.
        """
        results: dict[str, VulnerabilityScanResult] = {}

        python_result = await self.scan_python_dependencies(requirements_file)
        results["python_dependencies"] = python_result

        if image_reference and _is_trivy_available():
            container_result = await self.scan_container_image(image_reference)
            results["container_image"] = container_result

        logger.info(
            "All vulnerability scans complete",
            n_scan_types=len(results),
            any_threats=any(r.is_threat for r in results.values()),
        )

        return results

    def generate_report(
        self,
        results: dict[str, VulnerabilityScanResult],
        include_low_severity: bool = False,
    ) -> dict[str, Any]:
        """Generate a structured vulnerability report from scan results.

        Args:
            results: Dict mapping scan_type to VulnerabilityScanResult.
            include_low_severity: Include low and informational severity findings.

        Returns:
            Structured vulnerability report dict suitable for compliance reporting.
        """
        all_vulns: list[dict[str, Any]] = []
        total_critical = total_high = total_medium = total_low = 0

        for scan_type, result in results.items():
            total_critical += result.n_critical
            total_high += result.n_high
            total_medium += result.n_medium
            total_low += result.n_low

            for vuln in result.vulnerabilities:
                if not include_low_severity and vuln.get("severity") in ("low", "informational"):
                    continue
                all_vulns.append({**vuln, "scan_type": scan_type})

        overall_is_threat = total_critical > 0 or total_high > 0

        # Sort by CVSS score descending
        all_vulns.sort(key=lambda v: v.get("cvss_score", 0.0), reverse=True)

        return {
            "report_type": "vulnerability_scan",
            "overall_is_threat": overall_is_threat,
            "overall_severity": (
                "critical" if total_critical > 0
                else "high" if total_high > 0
                else "medium" if total_medium > 0
                else "low" if total_low > 0
                else "none"
            ),
            "summary": {
                "total_critical": total_critical,
                "total_high": total_high,
                "total_medium": total_medium,
                "total_low": total_low,
                "total_vulnerabilities": len(all_vulns),
            },
            "scan_results": {
                scan_type: {
                    "scanner": r.scanner_used,
                    "n_critical": r.n_critical,
                    "n_high": r.n_high,
                    "n_medium": r.n_medium,
                    "n_low": r.n_low,
                    "is_threat": r.is_threat,
                }
                for scan_type, r in results.items()
            },
            "vulnerabilities": all_vulns,
            "recommendations": self._generate_report_recommendations(
                total_critical, total_high, total_medium
            ),
        }

    async def _scan_with_pip_audit_api(
        self,
        requirements_file: str | None,
    ) -> VulnerabilityScanResult:
        """Scan using pip-audit Python API.

        Args:
            requirements_file: Optional requirements.txt path.

        Returns:
            VulnerabilityScanResult from pip-audit API scan.
        """
        try:
            from pip_audit import AuditSession, PyPISource

            source = PyPISource()
            session = AuditSession(source)

            vulnerabilities: list[dict[str, Any]] = []

            # pip-audit API varies by version — use subprocess fallback for portability
            return await self._scan_with_pip_audit_subprocess(requirements_file)

        except Exception as exc:
            logger.warning(
                "pip-audit API scan failed — falling back to subprocess",
                error=str(exc),
            )
            return await self._scan_with_pip_audit_subprocess(requirements_file)

    async def _scan_with_pip_audit_subprocess(
        self,
        requirements_file: str | None,
    ) -> VulnerabilityScanResult:
        """Scan using pip-audit subprocess with JSON output.

        Args:
            requirements_file: Optional requirements.txt path.

        Returns:
            VulnerabilityScanResult from pip-audit subprocess scan.
        """
        cmd = ["pip-audit", "--format", "json", "--progress-spinner", "off"]
        if requirements_file:
            cmd.extend(["-r", requirements_file])

        try:
            proc = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=60,
            )
            output = proc.stdout or proc.stderr or "[]"
            raw_results = json.loads(output) if output.strip().startswith("[") else []

        except subprocess.TimeoutExpired:
            logger.error("pip-audit scan timed out")
            raw_results = []
        except (json.JSONDecodeError, FileNotFoundError) as exc:
            logger.warning("pip-audit subprocess failed", error=str(exc))
            raw_results = []

        return self._parse_pip_audit_results(raw_results)

    def _parse_pip_audit_results(
        self,
        raw_results: list[dict[str, Any]],
    ) -> VulnerabilityScanResult:
        """Parse pip-audit JSON output into VulnerabilityScanResult.

        Args:
            raw_results: List of pip-audit result dicts.

        Returns:
            Structured VulnerabilityScanResult.
        """
        vulnerabilities: list[dict[str, Any]] = []

        for pkg_result in raw_results:
            pkg_name = pkg_result.get("name", "unknown")
            pkg_version = pkg_result.get("version", "unknown")

            for vuln in pkg_result.get("vulns", []):
                cve_id = vuln.get("id", "UNKNOWN")
                fix_versions = vuln.get("fix_versions", [])
                fixed_version = fix_versions[0] if fix_versions else "no fix available"
                description = vuln.get("description", "")
                aliases = vuln.get("aliases", [])

                # Estimate CVSS from description keywords (pip-audit doesn't always have CVSS)
                cvss_score = self._estimate_cvss_from_description(description)
                severity = self._cvss_to_severity(cvss_score)

                if not self._include_unfixed and fixed_version == "no fix available":
                    continue

                vulnerabilities.append({
                    "cve_id": cve_id,
                    "package_name": pkg_name,
                    "installed_version": pkg_version,
                    "fixed_version": fixed_version,
                    "severity": severity,
                    "cvss_score": cvss_score,
                    "description": description[:500],
                    "references": [f"https://osv.dev/vulnerability/{cve_id}"] + aliases[:3],
                    "remediation": (
                        f"Upgrade {pkg_name} to version {fixed_version}"
                        if fixed_version != "no fix available"
                        else f"No fix available for {cve_id} — consider replacing {pkg_name}"
                    ),
                    "scan_target": "python_deps",
                })

                if len(vulnerabilities) >= self._max_vulns:
                    break

        return self._build_result(vulnerabilities, "pip_audit", "python_deps")

    async def _scan_with_trivy(
        self,
        image_reference: str,
        include_os: bool,
        include_lang: bool,
    ) -> VulnerabilityScanResult:
        """Run Trivy container scan as subprocess.

        Args:
            image_reference: Docker image reference to scan.
            include_os: Include OS package vulnerabilities.
            include_lang: Include language package vulnerabilities.

        Returns:
            VulnerabilityScanResult from Trivy scan.
        """
        scanners = []
        if include_os or include_lang:
            scanners.append("vuln")

        cmd = [
            "trivy", "image",
            "--format", "json",
            "--quiet",
            "--no-progress",
        ]
        if scanners:
            cmd.extend(["--scanners", ",".join(scanners)])
        cmd.append(image_reference)

        try:
            proc = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=self._trivy_timeout,
            )
            raw = json.loads(proc.stdout) if proc.stdout else {}

        except subprocess.TimeoutExpired:
            logger.error(
                "Trivy scan timed out",
                image=image_reference,
                timeout=self._trivy_timeout,
            )
            return self._empty_result("trivy", "container")
        except (json.JSONDecodeError, FileNotFoundError) as exc:
            logger.warning("Trivy subprocess failed", error=str(exc))
            return self._empty_result("trivy", "container")

        return self._parse_trivy_results(raw, image_reference)

    def _parse_trivy_results(
        self,
        raw: dict[str, Any],
        image_reference: str,
    ) -> VulnerabilityScanResult:
        """Parse Trivy JSON output into VulnerabilityScanResult.

        Args:
            raw: Trivy JSON output dict.
            image_reference: Original image reference.

        Returns:
            Structured VulnerabilityScanResult.
        """
        vulnerabilities: list[dict[str, Any]] = []

        for result_set in raw.get("Results", []):
            target = result_set.get("Target", image_reference)
            class_type = result_set.get("Class", "os-pkgs")

            for vuln_data in result_set.get("Vulnerabilities", []):
                cve_id = vuln_data.get("VulnerabilityID", "UNKNOWN")
                pkg_name = vuln_data.get("PkgName", "unknown")
                installed_version = vuln_data.get("InstalledVersion", "unknown")
                fixed_version = vuln_data.get("FixedVersion", "no fix available")
                severity = vuln_data.get("Severity", "UNKNOWN").lower()
                cvss_score = vuln_data.get("CVSS", {})
                score = 0.0

                # Try to get CVSS v3 score
                for source_data in cvss_score.values():
                    v3_score = source_data.get("V3Score", 0.0)
                    if v3_score > score:
                        score = v3_score

                if score == 0.0:
                    score = self._cvss_from_severity(severity)

                description = vuln_data.get("Description", "")[:500]
                refs = vuln_data.get("References", [])[:5]

                if not self._include_unfixed and fixed_version == "no fix available":
                    continue

                vulnerabilities.append({
                    "cve_id": cve_id,
                    "package_name": pkg_name,
                    "installed_version": installed_version,
                    "fixed_version": fixed_version if fixed_version else "no fix available",
                    "severity": severity if severity in CVSS_SEVERITY_MAP else "medium",
                    "cvss_score": round(score, 1),
                    "description": description,
                    "references": refs,
                    "remediation": (
                        f"Upgrade {pkg_name} to {fixed_version}"
                        if fixed_version
                        else f"No fix available for {cve_id} in {pkg_name}"
                    ),
                    "scan_target": class_type,
                    "container_target": target,
                })

                if len(vulnerabilities) >= self._max_vulns:
                    break

        return self._build_result(vulnerabilities, "trivy", "container")

    def _build_result(
        self,
        vulnerabilities: list[dict[str, Any]],
        scanner_used: str,
        scan_target: str,
    ) -> VulnerabilityScanResult:
        """Build a VulnerabilityScanResult from a vulnerability list.

        Args:
            vulnerabilities: List of vulnerability dicts.
            scanner_used: Scanner name string.
            scan_target: Target type string.

        Returns:
            Populated VulnerabilityScanResult.
        """
        severity_counts = {"critical": 0, "high": 0, "medium": 0, "low": 0}
        for vuln in vulnerabilities:
            sev = vuln.get("severity", "low")
            if sev in severity_counts:
                severity_counts[sev] += 1

        fail_severities = self._get_fail_severities()
        is_threat = any(
            severity_counts.get(sev, 0) > 0 for sev in fail_severities
        )

        severity_order = ["critical", "high", "medium", "low"]
        max_severity = "none"
        for sev in severity_order:
            if severity_counts.get(sev, 0) > 0:
                max_severity = sev
                break

        logger.info(
            "Vulnerability scan complete",
            scanner=scanner_used,
            n_critical=severity_counts["critical"],
            n_high=severity_counts["high"],
            n_medium=severity_counts["medium"],
            n_low=severity_counts["low"],
            is_threat=is_threat,
        )

        return VulnerabilityScanResult(
            is_threat=is_threat,
            threat_type="vulnerability_detected" if is_threat else "none",
            severity=max_severity,
            confidence=1.0,  # CVE database matches are definitive
            details={
                "scanner": scanner_used,
                "scan_target": scan_target,
                "fail_on_severity": self._fail_on_severity,
            },
            vulnerabilities=vulnerabilities,
            n_critical=severity_counts["critical"],
            n_high=severity_counts["high"],
            n_medium=severity_counts["medium"],
            n_low=severity_counts["low"],
            scan_target=scan_target,
            scanner_used=scanner_used,
        )

    def _empty_result(self, scanner_used: str, scan_target: str) -> VulnerabilityScanResult:
        """Return an empty result for failed scans.

        Args:
            scanner_used: Scanner name.
            scan_target: Target type.

        Returns:
            Empty VulnerabilityScanResult with is_threat=False.
        """
        return VulnerabilityScanResult(
            is_threat=False,
            threat_type="none",
            severity="none",
            confidence=0.0,
            details={"scanner": scanner_used, "error": "scan_failed"},
            vulnerabilities=[],
            n_critical=0,
            n_high=0,
            n_medium=0,
            n_low=0,
            scan_target=scan_target,
            scanner_used=scanner_used,
        )

    def _get_fail_severities(self) -> list[str]:
        """Return all severity tiers at or above the fail_on_severity threshold.

        Returns:
            List of severity strings that should trigger is_threat=True.
        """
        severity_order = ["critical", "high", "medium", "low", "informational"]
        try:
            threshold_idx = severity_order.index(self._fail_on_severity)
            return severity_order[:threshold_idx + 1]
        except ValueError:
            return ["critical", "high"]

    def _cvss_to_severity(self, score: float) -> str:
        """Map a CVSS v3 score to a severity string.

        Args:
            score: CVSS v3 base score (0.0–10.0).

        Returns:
            Severity string.
        """
        for severity, (low, high) in CVSS_SEVERITY_MAP.items():
            if low <= score <= high:
                return severity
        return "informational"

    def _cvss_from_severity(self, severity: str) -> float:
        """Estimate a CVSS score from a severity label.

        Args:
            severity: Severity string ('critical', 'high', 'medium', 'low').

        Returns:
            Median CVSS score for the severity tier.
        """
        defaults = {"critical": 9.5, "high": 8.0, "medium": 5.5, "low": 2.0}
        return defaults.get(severity.lower(), 5.0)

    def _estimate_cvss_from_description(self, description: str) -> float:
        """Estimate CVSS score from vulnerability description keywords.

        Used as a fallback when pip-audit doesn't provide explicit CVSS scores.

        Args:
            description: Vulnerability description text.

        Returns:
            Estimated CVSS score.
        """
        desc_lower = description.lower()
        if any(kw in desc_lower for kw in ["remote code execution", "rce", "arbitrary code"]):
            return 9.8
        if any(kw in desc_lower for kw in ["sql injection", "auth bypass", "privilege escalation"]):
            return 8.5
        if any(kw in desc_lower for kw in ["denial of service", "dos", "memory corruption"]):
            return 7.5
        if any(kw in desc_lower for kw in ["information disclosure", "xxe", "ssrf"]):
            return 6.5
        if any(kw in desc_lower for kw in ["xss", "csrf", "open redirect"]):
            return 5.5
        return 5.0

    def _generate_report_recommendations(
        self,
        n_critical: int,
        n_high: int,
        n_medium: int,
    ) -> list[str]:
        """Generate prioritized remediation recommendations for the report.

        Args:
            n_critical: Count of critical vulnerabilities.
            n_high: Count of high vulnerabilities.
            n_medium: Count of medium vulnerabilities.

        Returns:
            List of recommendation strings.
        """
        recommendations: list[str] = []

        if n_critical > 0:
            recommendations.append(
                f"URGENT: {n_critical} critical vulnerabilities detected. "
                f"Block deployment and apply patches immediately. "
                f"Escalate to security team."
            )
        if n_high > 0:
            recommendations.append(
                f"HIGH PRIORITY: {n_high} high-severity vulnerabilities detected. "
                f"Schedule patch deployment within 7 days per security policy."
            )
        if n_medium > 0:
            recommendations.append(
                f"MEDIUM PRIORITY: {n_medium} medium-severity vulnerabilities detected. "
                f"Include in next scheduled maintenance window."
            )

        recommendations.append(
            "Run vulnerability scans on every container build and before each deployment. "
            "Integrate aumos-security-runtime scan gate into CI/CD pipeline."
        )
        recommendations.append(
            "Enable automatic dependency updates (e.g., Dependabot or Renovate) "
            "to reduce vulnerability exposure window."
        )

        return recommendations


__all__ = [
    "VulnerabilityScanner",
    "Vulnerability",
    "VulnerabilityScanResult",
    "CVSS_SEVERITY_MAP",
]
